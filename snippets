{
	"async-test": {
		"prefix": "a-test",
		"body": [
			"test(\"${1}\", () async { ${2}});",
		],
	},
	"export": {
		"prefix": "ex",
		"body": [
			"export \"${1}\";"
		]
	},	
	  "Getter MobX Store": {
		"prefix": "gmstore",
		"body": [
			"// ignore_for_file: must_be_immutable, library_private_types_in_public_api",
			"import 'package:mobx/mobx.dart';",
			"import 'package:equatable/equatable.dart';",
			"import 'package:dartz/dartz.dart';",
			"import 'package:nokhte/app/core/error/failure.dart';",
			"import 'package:nokhte/app/${1:core}/modules/${2}/domain/domain.dart';",
			"part '${3}_getter_store.g.dart';",
			"",
			"class ${4}GetterStore = _${4}GetterStoreBase with _$${4}GetterStore;",
			"",
			"abstract class _${4}GetterStoreBase extends Equatable with Store {",
			"final ${5} logic;",
			"",
			"_${4}GetterStoreBase({",
			"required this.logic,",
			"});",
			"",
			"Future<Either<Failure, ${6}>> call(${7} params) async => await logic(params);",
			"",
			"@override",
			"List<Object> get props => [];",
			"}"
			
		],
	  },
	"general store": {
	"prefix": "gen-store",
	"body": [
		  "// ignore_for_file: must_be_immutable, library_private_types_in_public_api",
		  "import 'package:mobx/mobx.dart';",
		  "import 'package:equatable/equatable.dart';",
		  "part '${1}_store.g.dart';",
		  "",
		  "class ${2}Store = _${2}StoreBase with _$${2}Store;",
		  "",
		  "abstract class _${2}StoreBase extends Equatable with Store {",
		  "",
		  "@override",
		  "List<Object> get props => [];",
		  "}"
		],
	},
	"general coordinator": {
		"prefix": "gen-coord",
		"body": [
			  "// ignore_for_file: must_be_immutable, library_private_types_in_public_api",
			  "import 'package:mobx/mobx.dart';",
			  "import 'package:equatable/equatable.dart';",
			  "part '${1}_coordinator.g.dart';",
			  "",
			  "class ${2}Coordinator = _${2}CoordinatorBase with _$${2}Coordinator;",
			  "",
			  "abstract class _${2}CoordinatorBase extends Equatable with Store {",
			  "",
			  "@override",
			  "List<Object> get props => [];",
			  "}"
			],
		},
	  "module coordinator mobx store":{
		"prefix": "modco-store",
		"body": [
			"// ignore_for_file: must_be_immutable, library_private_types_in_public_api",
			"import 'package:mobx/mobx.dart';",
			"import 'package:equatable/equatable.dart';",
			"import 'package:dartz/dartz.dart';",
			"import 'package:nokhte/app/core/error/failure.dart';",
			"import 'package:nokhte/app/core/modules/${1}/mobx/mobx.dart';",
			"part '${1}_coorinator_store.g.dart';",
			"",
			"class ${2}CoordinatorStore = _${2}CoordinatorStoreBase with _$${2}CoordinatorStore;",
			"",
			"abstract class _${2}CoordinatorStoreBase extends Equatable with Store {",
			"final ${3:Store1} ${4:StoreName};",
			"final ${5:Store1} ${6:StoreName};",
			"final ${7:Store1} ${8:StoreName};",
			"final ${9:Store1} ${10:StoreName};",
			"final ${11:Store1} ${12:StoreName};",
			"",
			"_${2}CoordinatorStoreBase({",
			"required this.${4},",
			"required this.${6},",
			"required this.${8},",
			"required this.${10},",
			"required this.${12},",
			"});",
			"@override",
			"List<Object> get props => [];",
			"}"
		],
	  },
	  "core module coordinator mobx store":{
		"prefix": "core-coordinator",
		"body": [
			"// ignore_for_file: must_be_immutable, library_private_types_in_public_api",
			"import 'package:mobx/mobx.dart';",
			"import 'package:equatable/equatable.dart';",
			"import 'package:dartz/dartz.dart';",
			"import 'package:nokhte/app/core/error/failure.dart';",
			"import 'package:nokhte/app/core/modules/${1}/mobx/mobx.dart';",
			"part '${1}_coordinator.g.dart';",
			"",
			"class ${2}Coordinator = _${2}CoordinatorBase with _$${2}Coordinator;",
			"",
			"abstract class _${2}CoordinatorBase extends Equatable with Store {",
			"final ${3:Store1} ${4:StoreName};",
			"final ${5:Store1} ${6:StoreName};",
			"final ${7:Store1} ${8:StoreName};",
			"final ${9:Store1} ${10:StoreName};",
			"final ${11:Store1} ${12:StoreName};",
			"",
			"_${2}CoordinatorBase({",
			"required this.${4},",
			"required this.${6},",
			"required this.${8},",
			"required this.${10},",
			"required this.${12},",
			"});",
			"@override",
			"List<Object> get props => [];",
			"}"
		],
	  },
	  "Main Future MobX Store": {
		"prefix": "mfstore",
		"body": [
			"// ignore_for_file: must_be_immutable, library_private_types_in_public_api",
			"import 'package:mobx/mobx.dart';",
			"import 'package:nokhte/app/core/mobx/mobx.dart';",
			"import 'package:dartz/dartz.dart';",
			"import 'package:nokhte/app${1:/core}/modules/${2:module}/domain/domain.dart';",
			"part '${3}_store.g.dart';",
			"",
			"class ${4}Store = _${4}StoreBase with _$${4}Store;",
			"",
			"abstract class _${4}StoreBase extends BaseMobxDBStore<${5:params}, ${6:returnEntity}>  with Store {",
			"",
			"@observable",
			"bool is${7} = false;",
			"",
			"final ${4} logic;",
			"_${4}StoreBase({required this.logic});",
			"",
			"",
			"@observable",
			"BaseFutureStore<${6}> futureStore = BaseFutureStore(",
			"baseEntity: Right(${8}.initial),",
			"entityFutureParam: ObservableFuture(",
			"Future.value(",
			"Right(${8}.initial)",
			"),",
			"),",
			");",
			"",
			"@override",
			"void stateOrErrorUpdater(result) {",
			"result.fold((failure) {",
			"errorMessage = mapFailureToMessage(failure);",
			"state=StoreState.initial;",
			"}, (${9}StatusEntity) {",
			"is${7} = ${9}StatusEntity.isSent;",
			"});",
			"}",
			"",
			"@override",
			"@action",
			"Future<void> call(params) async {",
			"state = StoreState.loading;",
			"futureStore.entityOrFailureFuture = ObservableFuture(",
			"logic(params)",
			");",
			"futureStore.unwrappedEntityOrFailure = ",
			"await futureStore.entityOrFailureFuture;",
			"stateOrErrorUpdater(futureStore.unwrappedEntityOrFailure);",
			"state = StoreState.loaded;",
			"}",
			"}"
		],
	  },
	  "Main Stream MobX Store": {
		"prefix": "mstrStore",
		"body": [
			"// ignore_for_file: must_be_immutable, library_private_types_in_public_api",
			"import 'package:mobx/mobx.dart';",
			"import 'package:nokhte/app/core/constants/entities.dart';",
			"import 'package:nokhte/app/core/mobx/mobx.dart';",
			"import 'package:nokhte/app/${1:core}/modules/${2:module}/domain/domain.dart';",
			"import 'package:nokhte/app/${1:core}/modules/${2:module}/presentation/presentation.dart';",
			"part '${3}_store.g.dart';",
			"",
			"class ${4}Store = _${4}StoreBase with _$${4}Store;",
			"",
			"abstract class _${4}StoreBase extends BaseMobxDbStore<${5:params}, ${6:returnEntity}>  with Store {",
			"",
			"final ${4}GetterStore getterStore;",
			"_${4}StoreBase({required this.getterStore});",
			"",
			"@observable",
			"ObservableStream<${6}> docContent = ObservableStream(",
			"DefaultEntities.${7},",
			");",
			"",
			"@override",
			"Future<void> call(params) async {",
			"final result = await getterStore();",
			"result.fold(",
			"(failure) {",
			"errorMessage = mapFailureToMessage(failure);",
			"state = StoreState.initial;",
			"},",
			"(${8}) {",
			"docContent = ObservableStream(${8}.${9});",
			"state = StoreState.loaded;",
			"},",
			");",
			"}",
			"",
			"}",
		],
	  },
	  "Widget Imports": {
		"prefix": "widgim",
		"body": [
			"import 'package:flutter/material.dart'; ",
			"import 'package:flutter_modular/flutter_modular.dart';",
			"import 'package:mobx/mobx.dart';",
			"import 'package:flutter_mobx/flutter_mobx.dart';"

		],
	  },
	  "Test Setup": {
		"prefix": "tset",
		"body": [
			"setUp(() {${1}});"
		],
	  },
	  "Module" : {
		"prefix": "module",
		"body": [
			"import 'package:nokhte/app/${1:core}/modules/${2}/data/data.dart';",
			"import 'package:nokhte/app/${1:core}/modules/${2}/domain/domain.dart';",
			"import 'package:nokhte/app/${1:core}/modules/${2}/presentation/presentation.dart';",
			"import 'package:supabase_flutter/supabase_flutter.dart';",
			"import 'package:flutter_modular/flutter_modular.dart';",
			"import 'package:nokhte/app/core/network/network_info.dart';",
			"class ${4}Module extends Module {",
  			"@override",
  			"binds(i)  {",
            "	}",
			"",
            "}",
			"",
			"@override",
			"routes(r) {}",
		]
	  },
	  "Modular bind": {
		"prefix": "bind",
		"body": [
			"Bind.singleton<${1}>(",
			"(i) => ${1}(",
			"${2}",
			"),",
			"),",
		],
	  },
	  "Exported Modular bind": {
		"prefix": "exbind",
		"body": [
			"Bind.singleton<${1}>(",
			"(i) => ${1}(",
			"${2}",
			"),",
			"export: true,",
			"),",
		],
	  },
		"Create Logic Class from Contract": {
		  "prefix": "logic",
		  "body": [
			"import 'package:nokhte/app/core/interfaces/logic.dart';",
			"import 'package:nokhte/app${1:/core}/modules/${2}/domain/domain.dart';",
			"import 'package:nokhte/app/core/interfaces/logic.dart';",
			"",
			"class ${3:YourLogicClassName} implements AbstractFutureLogic<${4:ReturnEntity}, ${5:NoParams}> {",
			"  final ${6:YourContractInterface} contract;",
			"",
			"  ${3:YourLogicClassName}({required this.contract});",
			"",
			"  @override",
			"  call(params) async => await contract.${7:methodName}(params);",
			"}"
		],
		"description": "Create a logic class implementing a contract"
	},
	"entity": {
		"prefix": "entity",
		"body": [
			"import 'package:equatable/equatable.dart';",
			"",
			"class ${1}Entity extends Equatable {",
			"final ${2} ${3};",
			"final ${4} ${5}",
			"final ${6} ${7}",
			"",
			"const ${1}Entity({required this.${3},",
			"required this.${4}",
			", required this.${6},",
			"});",
			"",
			"@override",
			"List<Object> get props => [${3}, ${4}, ${6}];",
			"}",
		],
	},
	"status entity": {
		"prefix": "status-entity",
		"body": [
			"import 'package:nokhte/app/core/entities/base_single_boolean_entity.dart';",
			"",
			"class ${1}StatusEntity extends BaseSingleBooleanEntity {",
			"const ${1}StatusEntity({required bool ${2}})",
			": super(isTrue: ${2});",
			"",
			"}",
		],
	},
	"logic params": {
		"prefix": "logic",
		"body": [
			"class ${1}Params extends Equatable {",
			"final ${1:Type} ${2:Name};",
			"final ${4} ${5};",
			"final ${6} ${7};",
			"",
			"const ${1}({required this.${2},",
			"required this.${4}",
			", required this.${6},",
			"});",
			"",
			"@override",
			"List<Object> get props => [${2}, ${4}, ${6},];",
			"}"
		],
	},
	"test logic": {
		"prefix": "tst-logic",
		"body": [
			"import 'package:dartz/dartz.dart';",
			"import 'package:flutter_test/flutter_test.dart';",
			"import 'package:mockito/mockito.dart';",
			"import 'package:nokhte/app/core/constants/failure_constants.dart';",
			"import 'package:nokhte/app/core/interfaces/logic.dart';",
			"import 'package:nokhte/app${1:/core}/modules/${2}/domain/domain.dart';",
			"import '../../constants/entities/entities.dart';",
			"import '../../fixtures/${2}_mock_gen.mocks.dart';",
			"",
			"void main() {",
			"late MockM${3}Contract mockContract;",
			"late ${4} logic;",
			"final tParams = ${5}",
			"",
			"setUp(() {",
			"mockContract = MockM${3}Contract();",
			"logic = ${4}(contract: mockContract);",
			"});",
			"",
			"test(\"✅ should pass the Status Entity from Contract ==> Logic\", () async {",
			"when(mockContract.${6}(tParams)).thenAnswer(",
			"(_) async => Constant${7}Entity.wrappedSuccessCase,",
			");",
			"",
			"final result = await logic(tParams);",
			"",
			"expect(result, Constant${7}Entity.wrappedSuccessCase);",
			"verify(mockContract.${6}(tParams));",
			"verifyNoMoreInteractions(mockContract);",
			"});",
			"",
			"test(\"✅ should pass A Failure from Contract ==> Logic\", () async {",
			"when(mockContract.${6}(tParams)).thenAnswer(",
			"(_) async => Left(FailureConstants.dbFailure),",
			");",
			"",
			"final result = await logic(tParams);",
			"",
			"expect(result, Left(FailureConstants.dbFailure));",
			"verify(mockContract.${6}(tParams));",
			"verifyNoMoreInteractions(mockContract);",
			"});",
			"}",
		],
	},
	"contract": {
		"prefix": "contract",
		"body": [
			"import 'package:dartz/dartz.dart';",
			"import 'package:nokhte/app/core/error/failure.dart';",
			"import 'package:nokhte/app/core/interfaces/logic.dart';",
			"import 'package:nokhte/app${1:/core}/modules/${2}/domain/domain.dart';",
			"",
			"abstract class ${3} {",
			"Future<Either<Failure, ${4:returnEntity}>> ${5:name}(${6:NoParams} params);",
			"Future<Either<Failure, ${7:returnEntity}>> ${8:name}(${9:NoParams} params);",
			"Future<Either<Failure, ${10:returnEntity}>> ${11:name}(${12:NoParams} params);",
			"Future<Either<Failure, ${13:returnEntity}>> ${14:name}(${15:NoParams} params);",
			"}"
		],
	},
	"constant entities": {
		"prefix": "constant entities",
		"body": [
			"import 'package:dartz/dartz.dart';",
			"import 'package:nokhte/app/core/error/failure.dart';",
			"import 'package:nokhte/app${1:/core}/modules/${2}/domain/domain.dart';",
			"class Constant${3}Entity {",
			"  static ${3}Entity get successCase =>",
			"      const ${3}Entity(${4}: ${5});",
			" static ${3}Entity get notSuccessCase =>",
			"     const ${3}Entity(${4}: ${6});",
			" static Either<Failure, ${3}Entity> get wrappedSuccessCase =>",
			"     Right(successCase);",
			" static Either<Failure, ${3}Entity> get wrappedNotSuccessCase =>",
			"     Right(notSuccessCase);",
			"}",
		],
	},
	"constant models": {
		"prefix": "constant models",
		"body": [
			"import 'package:dartz/dartz.dart';",
			"import 'package:nokhte/app/core/error/failure.dart';",
			"import 'package:nokhte/app${1:/core}/modules/${2}/data/data.dart';",
			"class Constant${3}Model {",
			"  static ${3}Model get successCase =>",
			"      const ${3}Model(${4}: ${5});",
			" static ${3}Model get notSuccessCase =>",
			"     const ${3}Model(${4}: ${6});",
			" static Either<Failure, ${3}Model> get wrappedSuccessCase =>",
			"     Right(successCase);",
			" static Either<Failure, ${3}Model> get wrappedNotSuccessCase =>",
			"     Right(notSuccessCase);",
			"}",
		],
	},
	"test contract-impl": {
		"prefix": "tst-contract",
		"body": [
			"import 'package:flutter_test/flutter_test.dart';",
			"import 'package:mockito/mockito.dart';",
			"import 'package:nokhte/app/core/constants/failure_constants.dart';",
			"import 'package:nokhte/app/core/modules/collaborative_doc/data/data.dart';",
			"import 'package:nokhte/app${1:/core}/modules/${2}/data/data.dart';",
			"import '../../constants/models/models.dart';",
			"import '../../fixtures/${2}_mock_gen.mocks.dart';",
			"import '../../../../../modules/_module_helpers/shared_mocks_gen.mocks.dart'",
			"    show MockMNetworkInfo;",
			"import 'package:dartz/dartz.dart';",
			"",
			"void main() {",
			"  late ${3}ContractImpl ${4}Contract;",
			"  late MockM${5}RemoteSource mockRemoteSource;",
			"  late MockMNetworkInfo mockNetworkInfo;",
			"",
			"  setUp(() {",
			"    mockRemoteSource = MockM${5}RemoteSource();",
			"    mockNetworkInfo = MockMNetworkInfo();",
			"    ${4}Contract = ${3}ContractImpl(",
			"      remoteSource: mockRemoteSource,",
			"      networkInfo: mockNetworkInfo,",
			"    );",
			"${6}",
			"  });",
			"",
			"}",
		],
	},
	"test contract impl method": {
		"prefix": "tst-contract-method",
		"body": [
			"  group(\"Method No. ${2}: ${3}\", () {",
			"    group(\"is Online\", () {",
			"      setUp(() {",
			"        when(mockNetworkInfo.isConnected).thenAnswer((_) async => true);",
			"      });",
			"      test(\"when online and non-empty should return a model\", () async {",
			"        when(mockRemoteSource.${3}(${4}))",
			"            .thenAnswer((realInvocation) async => ${5});",
			"        final res = await ${1}.${3}(",
			"${6}",
			"        );",
			"        expect(",
			"          res,",
			"          ${7}.wrappedSuccessCase,",
			"        );",
			"      });",
			"      test(\"when online and empty should return a model\", () async {",
			"        when(mockRemoteSource.${3}(${4}))",
			"            .thenAnswer((realInvocation) async => []);",
			"        final res = await ${1}.${3}(",
			"            ${6});",
			"        expect(res,",
			"            ${7}.wrappedNotSuccessCase);",
			"      });",
			"    });",
			"    group(\"is not Online\", () {",
			"      setUp(() {",
			"        when(mockNetworkInfo.isConnected).thenAnswer((_) async => false);",
			"      });",
			"",
			"      test(\"When offline should return an internet connection error\", () async {",
			"        final res = await ${1}.${3}(",
			"            ${6});",
			"        expect(res, Left(FailureConstants.internetConnectionFailure));",
			"      });",
			"    });",
			"  });",
		],
	},
	"test getter mobx store": {
		"prefix": "tst-gms",
		"body": [
			"import 'package:dartz/dartz.dart';",
			"import 'package:flutter_test/flutter_test.dart';",
			"import 'package:mockito/mockito.dart';",
			"import 'package:nokhte/app/core/constants/failure_constants.dart';",
			"import 'package:nokhte/app/core/error/failure.dart';",
			"import 'package:nokhte/app/core/interfaces/logic.dart';",
			"import 'package:nokhte/app${1:/core}/modules/${2:module}/domain/domain.dart';",
			"import 'package:nokhte/app${1:/core}/modules/${2:module}/mobx/mobx.dart';",
			"import '../../constants/entities/entities.dart';",
			"import '../../fixtures/${2}_mock_gen.mocks.dart';",
			"",
			"void main() {",
			"late MockM${3} mockLogic;",
			"late ${3}GetterStore getterStore;",
			"late Either<Failure, ${5}Entity>",
			"tEitherStatusOrFailure;",
			"final tParams = ${6};",
			"",
			"setUp(() {",
			"mockLogic = MockM${3}();",
			"getterStore = ${4}GetterStore(logic: mockLogic);",
			"});",
			"",
			"group(\"✅ Success Cases\", () {",
			"setUp(() {",
			"tEitherStatusOrFailure =",
			"Constant${5}Entity.wrappedSuccessCase;",
			"});",
			"",
			"test(\"should pass the right entity w/ the right state\", () async {",
			"when(mockLogic(tParams))",
			".thenAnswer((realInvocation) async => tEitherStatusOrFailure);",
			"final res = await getterStore();",
			"expect(res, tEitherStatusOrFailure);",
			"});",
			"});",
			"",
			"group(\"❌ Failure Cases\", () {",
			"setUp(() {",
			"tEitherStatusOrFailure = Left(FailureConstants.dbFailure);",
			"});",
			"",
			"test(\"should pass the right entity w/ the right state\", () async {",
			"when(mockLogic(tParams))",
			".thenAnswer((realInvocation) async => tEitherStatusOrFailure);",
			"final res = await getterStore();",
			"expect(res, tEitherStatusOrFailure);",
			"});",
			"});",
			"}",
		]
	},
	"test future main mobx store": {
		"prefix": "tst-fut-ms",
		"body": [
			"import 'package:dartz/dartz.dart';",
			"import 'package:flutter_test/flutter_test.dart';",
			"import 'package:mockito/mockito.dart';",
			"import 'package:nokhte/app/core/constants/failure_constants.dart';",
			"import 'package:nokhte/app/core/error/failure.dart';",
			"import 'package:nokhte/app/core/interfaces/logic.dart';",
			"import 'package:nokhte/app${1:/core}/modules/${2:module}/domain/domain.dart';",
			"import 'package:nokhte/app${1:/core}/modules/${2:module}/mobx/mobx.dart';",
			"import '../../constants/entities/entities.dart';",
			"import '../../fixtures/${2}_mock_gen.mocks.dart';",
			"void main() {",
			"  late MockM${3}GetterStore mockGetterStore;",
			"  late ${3}Store mainStore;",
			"  const tParams = ${4};",
			"",
			"  setUp(() {",
			"    mockGetterStore = MockM${3}GetterStore();",
			"    mainStore = ${3}Store(",
			"      getterStore: mockGetterStore,",
			"    );",
			"  });",
			"",
			"  group(\"stateOrErrorUpdater\", () {",
			"    test(\"✅ Success Case: should update accordingly if state is passed\", () {",
			"      mainStore.stateOrErrorUpdater(",
			"        Constant${5}Entity.wrappedSuccessCase,",
			"      );",
			"      expect(",
			"        mainStore.${6},",
			"        ${7},",
			"      );",
			"    });",
			"    test(\"❌ Success Case: should update accordingly if failure is passed\", () {",
			"      mainStore.stateOrErrorUpdater(",
			"        Left(FailureConstants.dbFailure),",
			"      );",
			"      expect(mainStore.${6}, ${8});",
			"      expect(",
			"          mainStore.errorMessage, FailureConstants.genericFailureMsg);",
			"    });",
			"  });",
			"  group(\"call\", () {",
			"    test(\"✅ Success Case: should update accordingly if state is passed\",",
			"        () async {",
			"      when(mockGetterStore(tParams)).thenAnswer(",
			"        (_) async =>",
			"            Constant${5}Entity.wrappedNotSuccessCase,",
			"      );",
			"      await mainStore(tParams);",
			"      expect(",
			"        mainStore.${6},",
			"        ${8},",
			"      );",
			"      expect(mainStore.errorMessage, \"\");",
			"    });",
			"    test(\"❌ Success Case: should update accordingly if failure is passed\",",
			"        () async {",
			"      when(mockGetterStore(tParams)).thenAnswer(",
			"        (_) async => Left(FailureConstants.dbFailure),",
			"      );",
			"      await mainStore(tParams);",
			"      expect(mainStore.${6}, ${8});",
			"      expect(",
			"          mainStore.errorMessage, FailureConstants.genericFailureMsg);",
			"    });",
			"  });",
			"}",
		]
	},
	"test stream main mobx store": {
		"prefix": "tst-str-ms",
		"body": [
			"import 'package:dartz/dartz.dart';",
			"import 'package:flutter_test/flutter_test.dart';",
			"import 'package:mockito/mockito.dart';",
			"import 'package:nokhte/app/core/constants/failure_constants.dart';",
			"import 'package:nokhte/app/core/error/failure.dart';",
			"import 'package:nokhte/app/core/interfaces/logic.dart';",
			"import 'package:nokhte/app${1:/core}/modules/${2:module}/domain/domain.dart';",
			"import 'package:nokhte/app${1:/core}/modules/${2:module}/presentation/presentation.dart';",
			"import '../../constants/entities/entities.dart';",
			"import '../../fixtures/${2}_mock_gen.mocks.dart';",
			"",
			"void main() {",
			"  late MockM${3}GetterStore mockGetterStore;",
			"  late ${3} mainStore;",
			"  const tParams = ${4};",
			"",
			"  setUp(() {",
			"    mockGetterStore = MockM${3}GetterStore();",
			"    mainStore = ${3}(",
			"      getterStore: mockGetterStore,",
			"    );",
			"  });",
			"  group(\"call\", () {",
			"    test(\"✅ Success Case: should update accordingly if state is passed\",",
			"        () async {",
			"      when(mockGetterStore(tParams)).thenAnswer(",
			"        (_) async =>",
			"            Constant${4}Entity.wrappedNotSuccessCase,",
			"      );",
			"      await mainStore(tParams);",
			"      expect(",
			"        mainStore.${5},",
			"        ${7},",
			"      );",
			"      expect(mainStore.errorMessage, \"\");",
			"    });",
			"    test(\"❌ Success Case: should update accordingly if failure is passed\",",
			"        () async {",
			"      when(mockGetterStore(tParams)).thenAnswer(",
			"        (_) async => Left(FailureConstants.dbFailure),",
			"      );",
			"      await mainStore(tParams);",
			"      expect(mainStore.${5}, ${7});",
			"      expect(",
			"          mainStore.errorMessage, FailureConstants.genericFailureMsg);",
			"    });",
			"  });",
			"}",
		]
	},
	"test model": {
		"prefix": "tst-model",
		"body": [
			"import 'package:flutter_test/flutter_test.dart';",
			"import 'package:nokhte/app/${1:core}/modules/${2:module}/data/data.dart';",
			"import '../../constants/models/models.dart';",
			"",
			"void main() {",
			"  test('`fromSupabase` should return entity w/ false if empty array is given',",
			"      () {",
			"    final res = ${3}Model.fromSupabase([]);",
			"    expect(res, ${4}StatusModel.notSuccessCase);",
			"  });",
			"  test(",
			"      '`fromSupabase` should return entity w/ true if non-empty array is given',",
			"      () {",
			"    final res = ${3}Model.fromSupabase([{}]);",
			"    expect(res, ${4}StatusModel.successCase);",
			"  });",
			"}",
		]
	},
	"mock gen template": {
		"prefix": "mck-gen",
		"body": [
			"import 'package:mockito/mockito.dart';",
			"import 'package:mockito/annotations.dart';",
			"import 'package:nokhte/app${1:/core}/modules/${2}/data/data.dart';",
			"import 'package:nokhte/app${1:/core}/modules/${2}/domain/domain.dart';",
			"import 'package:nokhte/app${1:/core}/modules/${2}/presentation/presentation.dart';",
			"",
			"@GenerateMocks([])",
			"",
			"void main() {}"
		],
	},
	"model": {
		"prefix": "model",
		"body": [
			"import 'package:nokhte/app${1:/core}/modules/${2}/domain/domain.dart';",
			"",
			"class ${3}Model extends ${3}Entity {",
			"const ${3}Model({required super.${4}});",
			"}",
		],
	},
	"status model": {
		"prefix": "status-model",
		"body": [
			"import 'package:nokhte/app${1:/core}/modules/${2}/domain/domain.dart';",
			"",
			"class ${3}Model extends ${3}Entity {",
			"const ${3}Model({required super.${4}});",
			"",
			"static ${3}Model fromSupabase(List res) {",
			"if(res.isEmpty) {",
			"return const ${3}Model(${4}: ${5});",
			"}",
			"else {",
			"return const ${3}Model(${4}: ${6});",
			"}",
			"}",
			"}",
		],
	},
	"remote source": {
		"prefix": "rs",
		"body": [
			"abstract class ${1}RemoteSource {",
			"Future<$2> ${3}();",
			"Future<$4> ${5}();",
			"Future<$6> ${7}();",
			"}",
		]
	},
	"remote source impl": {
		"prefix": "rs-impl",
		"body": [
			"class ${1}RemoteSourceImpl implements ${1}RemoteSource {}",
		],
	},
	"contract impl": {
		"prefix": "contract-impl",
		"body": [
			"import 'package:nokhte/app${1:/core}/modules/${2}/domain/domain.dart';",
			"import 'package:nokhte/app${1:/core}/modules/${2}/data/data.dart';",
			"import 'package:nokhte/app/core/network/network_info.dart';",
			"import 'package:nokhte/app/core/constants/failure_constants.dart';",
			"",
			"class ${3}ContractImpl implements ${3}Contract {",
			"final ${3}RemoteSource remoteSource;",
			"final NetworkInfo networkInfo;",
			"",
			"${3}ContractImpl({",
			"required this.remoteSource,",
			"required this.networkInfo",
			"});",
			"}"
		],
	},
	"contract impl method": {
		"prefix": "contract-method-body",
		"body": [
			"if (await networkInfo.isConnected) {",
			"final res = await remoteSource.${1};",
			"return Right(${2}Model);",
			"} else {",
			"return Left(FailureConstants.internetConnectionFailure);",
			"}",
		]
	}
}
